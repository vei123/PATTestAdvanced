#include<cstdio>
using namespace std;
int n, l;
long double d, res = 0.0;
signed main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%llf", &d);
		res += d * i * (1 + n - i);
	}
	printf("%.2llf", res);
	return 0;
}

/*一道数学题，10e5的数据量代表不能用前缀和数组双层循环计算，一定会超时，
故一定存在某种数学规律，能够用不超过O(n)的复杂度求出和
很容易发现每个位置上的数字出现次数是有规律的：
对于有n个数的输入，最左边和最右边的数字一定只能出现n次，越靠近中间
出现次数可以越多，对于每一个数字，假如它左边有i(i从1到n)个数字(包括它自己)，
右边有n-i+1个数字(也包括它自己)，那么该数字只能出现在开头是左边那i个数字之一，
结尾是右边那n-i+1个数字之一的这些个区间里，根据排列组合乘法原理一共有i*(n-i+1)个区间，
所以该数字出现了i*(n-i+1)次，这样我们可以在一次遍历中，每次以常数
复杂度求出某个数字出现的总和，依次累加即可在O(n)复杂度内得到结果
如果想不到乘法原理，其实也可以归纳出这个公式：
i位置上的数字，出现次数是1+2+...+m+...+2+1，
其中m=min(i,n-i+1)，表示从左往右和从右往左数中较小的那个序号，
那么假如2*m<=n，这个数字出现次数是：
1+2+...+m+m+m...+2+1，发现是两个相同等差数列，加一个全是m的数列，
总和为(1+m)*m+(n-2*m)*m = m*(n-m+1)
假如2*m>n，还是用两个等差数列相加，这时多算了(2*m-n)个m：
总和为(1+m)*m-(2*m-n)*m = m*(n-m+1)，与上一种情况一样，
再分别带入m=i，m=n-i-1(因为m=min(i,n-i+1))，发现最后结果也等于同一个等式：
i * (1 + n - i)
所以综上所述，每个数字出现了i * (1 + n - i)次，其中i∈[1, n]是该数字的下标
*/
