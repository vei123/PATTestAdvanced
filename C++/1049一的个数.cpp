#include<iostream>
using namespace std;

//时间复杂度：对于n<=99999，为O(n)，对于n>99999，为O(1)
//又是一道数学题。此题数据量2^30~=10^9，非常大，直接遍历计算明显超时，
//故可以采取如下的一次分治思想：

//①将输入数据取出高于100000的部分(设为L)和模100000(设为R)的部分，
//例如对10106789，可以分为101和6789，
//②然后我们只需计算从1到99999的各数据下的结果，并存在数组c[]中，之后
//对于任意给定的小于100亿的数据，均可在常数时间内求解，
//只需要作如下统计：
//若n<=99999，直接从c[]中取答案，即得到结果
//若n>99999，可以分别统计高位部分和低位部分的‘1’个数
//	对于低位部分的‘1’的个数：
//		如果左部取小于L的数时，右部可以任意(0~99999)，即左部有L种情况，乘以c[99999]
//		如果左部取到L时，注意右部只能取从0到R的数，即只有一种情况，乘以c[R]
//		故低位部分1的个数为c[99999] * L + c[R] 
//	对于高位部分的‘1’的个数：
//		如果右部取小于等于R的数时，左部可以任取L(0~L)，即右部有R+1种情况，乘以c[L]
//		如果右部取大于R的数，左部可以取小于L的数(0~L-1)，即右部有99999-R种情况，乘以c[L-1]
//		故高位部分1的个数为c[L] * (R + 1) + c[L - 1] * (99999 - R)
//例如对于10100032：
//答案为：c[99999] * 101 + c[32]+ c[101] * (32 + 1) + c[100] * (99999 - 32)

inline int countone(int n)
{
	int res = 0;
	while (n)
	{
		if (n % 10 == 1) res++;
		n /= 10;
	}
	return res;
}

signed main()
{
	ios::sync_with_stdio(0);
	int n, t = 0, c[100005] = { 0 };
	cin >> n;
	int l = n / 100000, r = n % 100000;
	for (int i = 1; i < 100000; i++) c[i] = c[i - 1] + countone(i);
	if (l) cout << c[l] * (r + 1) + c[l - 1] * (99999 - r) + c[r] + c[99999] * l;
	else cout << c[r];
	return 0;
}
