#include<iostream>
using namespace std;

int n, unmatch = 0, cnt = 0;
int f[100005], a[100005];

int getroot(int i)
{
	return f[i] == i ? i : f[i] = getroot(f[i]);
}

signed main()
{
	ios::sync_with_stdio(0);
	cin >> n;
	for (int i = 0; i < n; i++) f[i] = i;
	for(int i = 0; i < n; i++)
	{
		cin >> a[i];
		if (a[i] != i)
		{
			f[getroot(i)] = getroot(a[i]);
			unmatch++;
		}
	}
	for (int i = 0; i < n; i++)
		if (f[i] == i) cnt++;
	int res = 2 * unmatch + cnt - n - 2;
	cout << (a[0] ? res : res + 2);
	return 0;
}

/*一道纯数学题，自己半天推导出如下一个经验公式：
需要进行的交换数 = 2 * 初始不匹配数 + 数列“连通分量”个数 - 数字总个数 - 2
对应于代码中的 int res = 2 * unmatch + cnt - n - 2;
特别地，对于0一开始就在开头的情况，需要在上述结果的基础上加上2
对应于代码中的 (a[0] ? res : res + 2)

下面来解释公式中的名词：
初始不匹配数：对应于下面程序中的unmatch变量，表示开始时，不在正确的
位置上的数字个数，举个例子，以题目中的{4, 0, 2, 1, 3}为例子，
index : 0 1 2 3 4
a[i]  : 4 0 2 1 3
可以发现不在正确位置上的数字有4, 0, 1, 3，而2在自己正确的位置上，所以unmatch = 4;
数列“连通分量”数：这个概念有点抽象，但学过图论的应该对图论的连通分量有了解，
可以结合图论的连通分量来理解：
还是以上面的数列为例:
我们可以把这个数列中的数字分为如下2个集合
{0, 4, 3, 1}, {2}

这是什么意思呢？
假设我们从index中的数字0出发，找到位置0对应的数字a[0] = 4，
再从index = 4找到对应的数字a[4] = 3，
再从index = 3找到对应的数字a[3] = 1，
再从index = 1找到对应的数字a[1] = 0，
这里又回到了开始的index即0，我们发现子数列{0, 4, 3, 1}构成了一个“循环”，
我们把这个循环成为数列的一个连通分量，表示从其中的任何一个数字出发，可以到达
数列中的任何其它一个数字，但却到不了任何不在这个数列中的数字
对于子数列{2},同理

我们来计算一下结果 res = 2 * 4 + 2 - 5 - 2 = 3，
又由于a[0]!=0，故不需要加上2，所以答案为3

再以题目中的样例为例子：
{3 5 7 2 6 4 9 0 8 1}
初始只有数字8在正确的位置上，所以不匹配数unmatch = 10 - 1 = 9
index: 0 1 2 3 4 5 6 7 8 9
a[i] : 3 5 7 2 6 4 9 0 8 1
连通分量有{0, 3, 2, 7}, {1, 5, 4, 6, 9}, {8}
结果:res = 2 * 9 + 3 - 10 - 2 = 9，同理由于a[0]!=0, 不需要加2

对于a[0]等于0的情况，比如
index: 0 1 2 3 4
a[i] : 0 3 4 1 2
res = 2 * 4 + 3 - 5 - 2 = 4，需要在res的基础上再加2，
即res的正确结果为res = 4 + 2 = 6

下面来解释这个公式的正确性：
其实这个公式的更好理解的形式如下：(之所以写成上面那样是程序实现时的遗留产物...)
不匹配数 + 除开匹配正确的数字之外的连通分量数 - 2 （对于a[0]==0仍需加二)
除开匹配正确的数字之外的联通分量，以之前的例子：
index : 0 1 2 3 4
a[i]  : 4 0 2 1 3
那就是除开{2}之外的连通分量，只有{0, 4, 3, 1}
所以res = 4 + 1 - 2 = 3，由于a[0]!=0，故不需要加二

到这里，如果数学好，你可能就明白含义了：
简单说来就是
①对于同一个连通分量内的数字，可以进行一组连贯的0交换来让其中的
数字都在正确位置上
②对于多个连通分量的情况下，不同连通分量之间的切换需要额外的一个0交换开销
③对于0开始在正确的位置上的情况，更多两个开销(先把0放到某一个连通分量内，最后
还得换回来)
所以公式其实就是这三点的一个反应而已，如果还没理解可以自己推敲

代码实现中使用了并查集来计算连通分量，所以复杂度很低，总复杂度接近于O(n)，
至于并查集怎么实现的可以自行去学习
*/
